---
title: "Using ipf"
author: "Kyle Ward"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ipf}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=FALSE,echo=TRUE,
                      message=TRUE,warning=TRUE,error=TRUE)
options(scipen=999) # removes sci notation
```

## Introduction

This package provides a generic implimentation of the iterative proportional 
fitting algorithm or [IPF](https://en.wikipedia.org/wiki/Iterative_proportional_fitting).

## Example data creation

This section creates a random seed table and target values to illustrate 
how the package is used.

### Seed table creation
The seed table is the starting point for the IPF procedure.  In this example, 
we will use a made up summary table of survey data.  This fake table is a count 
of households by the number persons, workers and vehicles.  A sample of the 
table is shown for illustration.  The count is stored in the `weight` field.
```{r "seed creation", message=FALSE,warning=FALSE,error=FALSE}
library(dplyr)
library(tidyr)
library(ipfr)
library(htmlTable)

seed <- expand.grid(
  siz = c(1, 2, 3, 4),
  wrk = c(0, 1, 2, 3),
  veh = c(0, 1, 2, 3)
) %>% tbl_df()

set.seed(1)
seed$weight <- sample(1:10, nrow(seed), replace = TRUE)

seed %>%
  head() %>%
  htmlTable(
  align = "cccr", col.rgroup = c("none", "#F7F7F7"), rnames = FALSE
)
```


### Target creation
The number of households by size (e.g., 1-person, 2-person, etc.) is referred to
as a marginal distribution.  Often, from the Census, we know the total number of 
households by each individual marginal.  For example, we know the number of 
households by size:

  * 1 person: 150 households
  * 2 persons: 150 households
  * 3 persons: 100 households
  * 4+ persons: 100 households

This information becomes the target that the IPF process tries to match.

This information is created below for the distribution of households by size, 
number of workers, and number of vehicles.  The size table is shown as an example.
```{r "marginal creation"}

targets <- list()
targets$siz <- data_frame(
  ID = c(1, 2, 3),
  `1` = c(100, 150, 0),
  `2` = c(100, 100, 0),
  `3` = c(150, 100, 0),
  `4` = c(150, 150, 0)
)
targets$wrk <- data_frame(
  ID = c(1, 2, 3),
  `0` = c(100, 100, 0),
  `1` = c(150, 100, 0),
  `2` = c(150, 150, 0),
  `3` = c(100, 150, 0)
)
targets$veh <- data_frame(
  ID = c(1, 2, 3),
  `0` = c(75, 175, 0),
  `1` = c(175, 75, 0),
  `2` = c(150, 150, 0),
  `3` = c(100, 100, 0)
)

targets$siz %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Size Targets"
  )  
```

## Using ipfr
We know the count of each marginal individually, but assume we don't have 
official information from the Census about the joint distribution.  What we want
to do is use the joint distribution from our survey, but ensure it agrees with 
the marginal information from the Census.

An initial test comparing size shows they do not agree.
```{r "initial test"}
siz <- targets$siz %>%
  filter(ID == 1) %>%
  gather(key = siz, value = target, -ID) %>%
  mutate(siz = as.numeric(siz)) %>%
  select(-ID)
  

seed %>%
  select(siz, weight) %>%
  group_by(siz) %>%
  summarize(seed = sum(weight)) %>%
  left_join(siz, by = "siz") %>%
  htmlTable(
    align = "crr", rnames = FALSE
  )
```

We can use the ipfr package to change this.  For this example, the `verbose`
option is turned on to show what the tool reports upon completion.
```{r}
table <- ipf(seed, targets, verbose = FALSE)
```

A sample of the resulting table is shown below.
```{r}
table %>%
  mutate_each(funs(round(., 2))) %>%
  head() %>%
  htmlTable(
    align = "crr", rnames = FALSE
  )
```

We can summarize the final table to see if it worked.
```{r}
table %>%
  select(-c(wrk, veh)) %>%
  group_by(ID, siz) %>%
  summarize(total = round(sum(weight), 0)) %>%
  spread(key = siz, value = total) %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Size: Result"
  )

targets$siz %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Size: Target"
  )
```

Not only does the marginal distribution of size match, but also workers and vehicles.
```{r, echo=FALSE}
# Workers
table %>%
  select(-c(siz, veh)) %>%
  group_by(ID, wrk) %>%
  summarize(total = round(sum(weight), 0)) %>%
  spread(key = wrk, value = total) %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Workers: Result"
  )

targets$wrk %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Workers: Target"
  )

# Vehciles
table %>%
  select(-c(siz, wrk)) %>%
  group_by(ID, veh) %>%
  summarize(total = round(sum(weight), 0)) %>%
  spread(key = veh, value = total) %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Vehicles: Result"
  )

targets$veh %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Vehciles: Target"
  )
```

## Addressing common IPF problems

### Zero weights
IPF works by successively multiplying the table weights by factors.  Cells with 
a zero weight cannot be modified by this process.  As the number of zero weights 
increase, the flexibility of the process is reduced, and convergence becomes 
more difficult. `ipfr` solves this problem by setting a minimum weight for all 
cells to `.0001`.  This minimum weight can be adjusted using the `min_weight` 
parameter and should be arbitrarily small compared to your seed table weights.


### Missing seed information
Not every combination of marginal categories is required to be included in the 
seed table; however, at least one observation of each category must exist.  For example, the combination:

  * siz = 1
  * wrk = 1
  * veh = 0

may not have been observed in the survey, and thus may be missing from the seed 
table.  As long as other combinations of size-1 households exist (e.g. with 0 workers and 1 vehicle), `ipfr` will work fine.  On the other hand, if there are no observations of any size-1 households, `ipfr` will stop with an error message.

```{r, warning=TRUE}
missing_seed <- seed %>%
  filter(siz != 1)

error <- try(table <- ipf(missing_seed, targets))
error[1]
```

### Marginal agreement
In our example, the marginal distributions all add up to the same number for each zone (500, 500, and 0). If they disagreed on the total number of households, the standard IPF process could not converge.

Occasionally, marginal distributions might disagree slightly on the totals, particularly 
if they are derived from different sources.  When that happens, `ipfr` 
will still converge by matching the total of the first marginal table supplied 
while using the percentage distribution from the remaining tables.

```{r, warning=TRUE}
# Increase 1-person households from 100 to 500
targets$siz <- data_frame(
  ID = c(1, 2, 3),
  `1` = c(500, 500, 0),
  `2` = c(100, 100, 0),
  `3` = c(150, 100, 0),
  `4` = c(150, 150, 0)
)

table <- ipf(seed, targets)
```

```{r, echo=FALSE}
# Size
table %>%
  select(-c(wrk, veh)) %>%
  group_by(ID, siz) %>%
  summarize(total = round(sum(weight), 0)) %>%
  spread(key = siz, value = total) %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Size: Result"
  )

targets$siz %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Size: Target"
  )

# Workers
table %>%
  select(-c(siz, veh)) %>%
  group_by(ID, wrk) %>%
  summarize(total = round(sum(weight), 0)) %>%
  spread(key = wrk, value = total) %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Workers: Result"
  )

targets$wrk %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Workers: Target"
  )

# Vehciles
table %>%
  select(-c(siz, wrk)) %>%
  group_by(ID, veh) %>%
  summarize(total = round(sum(weight), 0)) %>%
  spread(key = veh, value = total) %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Vehicles: Result"
  )

targets$veh %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Vehciles: Target"
  )
```

### Partial marginals
In some applications of IPF, there may not be a need to control every category of every marginal.  In this example, perhaps you want to control 1-, 2-, and 3-person households, but are not concerned with 4+ person households. `ipfr` can handle a partial marginal table.

```{r}
partial_targets <- targets
partial_targets$siz <- data_frame(
  ID = c(1, 2, 3),
  `1` = c(100, 150, 0),
  `2` = c(100, 100, 0),
  `3` = c(150, 100, 0)
)

table <- ipf(seed, partial_targets)
```

As shown below, the marginal distributions of size categories 1, 2, and 3 are fairly close to their target values, while 4+ is not.

```{r}
table %>%
  select(-c(wrk, veh)) %>%
  group_by(ID, siz) %>%
  summarize(total = round(sum(weight), 0)) %>%
  spread(key = siz, value = total) %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Size: Result"
  )

partial_targets$siz %>%
  htmlTable(
    align = "crr", rnames = FALSE, caption = "Size: Target"
  )
```

